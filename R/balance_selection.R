#' Selection of the optimal balance of microbiome associated with survival outcomes
#'
#' \code{balances_selection()} identifies the log-ratio of geometric means of two sets of taxa that is most associated with the survival outcome using a greedy forward stepwise selection approach
#'
#' @param Surv_obj An object of class \code{Surv} generated by
#' \code{\link[survival:Surv]{survival::Surv}}
#' @param data A \eqn{n \times p} matrix which is the raw taxon count table,
#' where rows are the samples, columns are the taxa
#' @param covariates A \eqn{n \times q} data frame containing important covariates for adjustment,
#' which could be a mixture of \eqn{q} continuous and discrete (pre-defined as factor) variables.
#' The default value is \code{NULL}
#' @param min_prevalence The minimum prevalence of taxa that could be considered
#' in the selection procedure. The default value is \code{0.1}
#' @param mult_repl A logical variable indicating which algorithm is used to
#' process the raw taxon count table. If \code{TRUE} then the geometric Bayesian Multiplicative
#' Replacement (\code{\link[zCompositions:cmultRepl]{zCompositions::cmultRepl}})
#' is used to impute the inflated zeros. Otherwise, a small pseudo count (\code{0.5})
#' will be added to all raw counts. Finally, either processed data will be converted
#' to relative abundance, then log of relative abundance will be used in the selection procedure.
#' The default value is \code{TRUE}
#' @param model Specifies which kind of survival regression model is built.
#' The options are ``\code{coxph}'' (\code{\link[survival:coxph]{survival::coxph}}) and
#' ``\code{parametric}'' (\code{\link[survival:survreg]{survival::survreg}}).
#' The default value is ``\code{coxph}''
#' @param dist Specifies which kind of parametric distribution is used if
#' \code{model} is ``\code{parametric}''. The options include ``\code{weibull}'',
#' ``\code{exponential}'', ``\code{gaussian}'', ``\code{logistic}'', ``\code{lognormal}''
#' and ``\code{loglogistic}''. For more details, please see
#' \code{\link[survival:survreg]{survival::survreg}}. The default value is ``\code{weibull}''
#' @param stopping_pvalue The threshold of p-value to stop the forward search.
#' The forward search where, at each step, a new taxon is added to the existing
#' balance, will be stopped if the resulting p-value is larger than \code{stopping_pvalue}.
#' The default value is \code{0.15}
#' @param sequential_test A logical variable indicating whether sequential testing, in addition to
#' \code{stopping_pvalue}, is used to stop the forward search. If \code{TRUE}, the forward search where, at each step,
#' a new taxon is added to the existing balance, will be stopped
#' if the new balance is not significantly different from the current one
#' in the survival regression model. The default value is \code{FALSE}
#' @param sequential_alpha The level of significance for the sequential testing
#' if \code{sequential_test} is \code{TRUE}. The default value is \code{0.25}
#' @param selection_criterion The criterion to select balance in the final model.
#' The options include ``\code{min_pvalue}'' and ``\code{min_decrement_pvalue}''. If ``\code{min_pvalue}'' is used,
#' the balance that has the smallest p-value along the forward selection path will be selected.
#' If ``\code{min_decrement_pvalue}'' is used, the decrement of p-value along the forward selection path will be calculated,
#' the balance before the first decrement that is smaller than \code{selection_threshold} will be selected.
#' The default value is ``\code{min_decrement_pvalue}''
#' @param selection_threshold A threshold of p-value decrement used for balance selection in the final model if \code{selection_criterion}
#' is ``\code{min_decrement_pvalue}''. The default value is \code{0.15}
#' @param quantile_plotted A vector specifies the quantiles of the final selected
#' balance that will be shown in the
#' survival plot. The default value is \code{c(0.25, 0.5, 0.75)}
#' @param alpha The level of significance for survival plot of the final selected
#' balance. The corresponding confidence intervals will be shown in the survival
#' plot. The default value is \code{0.05}
#'
#' @return
#' \code{balance_selection} return a list containing the following components:
#' \item{selection_path}{A matrix showing the forward selection path. If \code{sign}
#' is \code{1}, the corresponding taxon is in the numerator of the balance;
#' If \code{sign} is \code{0}, the corresponding taxon is in the denominator of the balance.
#' \code{p_value} is the p-value of the balance consisting of taxa up to the current taxon}
#' \item{survival_model}{An object of class \code{coxph} or \code{survreg} depending on the user's input, which is the final model with the final selected balance of microbiome}
#' \item{balance_name}{A list containing names of the taxa in the numerator and the denominator of the final selected balance}
#' \item{balance}{The value of the final selected balance of microbiome for each sample}
#' \item{survival_plot}{A plot of survival curves with confidence intervals, stratified by chosen quantiles of the final selected balance of microbiome}
#'
#' @export
#'
#' @import survival
#' @import zCompositions
#' @import survminer
#' @import ggplot2
#' @import nonnestcox
#' @import boot
#' @import stats
#'
#' @references Rivera-Pinto, J., Egozcue, J. J., Pawlowsky-Glahn, V., Paredes, R., Noguera-Julian, M., & Calle, M. L. \emph{"Balances: a new perspective for microbiome analysis"}. MSystems 3.4 (2018): 10-1128
#' @references Fine, J. P. \emph{"Comparing nonnested Cox models"}. Biometrika 89.3 (2002): 635-648
#' @references Wahrendorf, J., Becher, H., & Brown, C. C. \emph{"Bootstrap comparison of non‚Äênested generalized linear models: applications in survival analysis and epidemiology"}. Journal of the Royal Statistical Society: Series C (Applied Statistics) 36.1 (1987): 72-81

#' @examples
#'
#' balance_selection(Surv_obj = gvhd, data = bacteria, mult_repl = TRUE,
#' model = "coxph", selection_criterion = "min_pvalue")
#'
#' balance_selection(Surv_obj = gvhd, data = bacteria, mult_repl = FALSE,
#' model = "parametric", dist = "weibull", selection_criterion = "min_decrement_pvalue")

balance_selection <- function(Surv_obj, data, covariates=NULL,
                              min_prevalence=0.1, mult_repl=TRUE,
                              model="coxph", dist="weibull",
                              stopping_pvalue=0.15, sequential_test=FALSE, sequential_alpha=0.25,
                              selection_criterion="min_decrement_pvalue", selection_threshold=0.15,
                              quantile_plotted=c(0.25, 0.5, 0.75), alpha = 0.05) {

  ### step 0
  # add some sanity check before processing

  if (length(Surv_obj) != nrow(data)) stop("The length of Surv_obj should be the same as the number of rows of data, which is the sample size.")
  
  if (model == "parametric"){
  if (any(Surv_obj[,"time"] == 0, na.rm = TRUE)) {
    stop('Error: The survival time contains zero. To use "parametirc" model, please exclude samples with zero survival time. Otherwise, please use "coxph" model.')
  }
  }
  
    
  processed_data = pre_processing(data=data, min_prevalence=min_prevalence, mult_repl=mult_repl)

  ### initialize everything, used for step1 to step3
  selected = matrix(ncol=4, nrow=ncol(processed_data))
  colnames(selected) = c("taxon_id", "sign", "p_value", "sequential_sig")
  tracker = 0
  candidates = 1:ncol(processed_data)

  ### step 1
  step1 = taxon_finding_first(Surv_obj=Surv_obj, data=processed_data, covariates=covariates, candidates=candidates, tracker=tracker, model=model, dist=dist)
  tracker = step1$tracker
  candidates = step1$candidates
  selected[1:tracker, 1:3] = step1$result

  ### step 2
  while (selected[tracker, 'p_value'] < stopping_pvalue & length(candidates) > 0 & (is.na(selected[tracker, 'sequential_sig']) | selected[tracker, 'sequential_sig'] == 1)) {
    step2 = taxon_finding_second(Surv_obj=Surv_obj, data=processed_data, covariates=covariates,
                                 candidates=candidates, tracker=tracker, selected=selected, model=model, dist=dist,
                                 sequential_test=sequential_test, sequential_alpha=sequential_alpha)
    tracker = step2$tracker
    candidates = step2$candidates
    selected[tracker, 1:3] = step2$result
    selected[tracker, 4] = step2$sig
  }

  ### step 3
  mod = select_model(selected=selected, criterion=selection_criterion, threshold=selection_threshold)
  rownames(mod) = colnames(processed_data)[mod[, 'taxon_id']]

  selected_positive_final = rownames(mod)[which(mod[, 2] == 1)] 
  positive_comp = apply( processed_data[, selected_positive_final, drop=F], 1, mean)

  selected_negative_final = rownames(mod)[which(mod[, 2] == 0)]
  negative_comp = apply( processed_data[, selected_negative_final, drop=F], 1, mean)

  balance_name = list()
  balance_name[["numerator"]] = selected_positive_final
  balance_name[["denominator"]] = selected_negative_final
  balance = positive_comp - negative_comp


  ### plot
  if (is.null( covariates )){
    df = data.frame(balance)
    balance_quantiles = quantile(balance, prob=quantile_plotted)
    balance_df = with(df, data.frame(balance = balance_quantiles))
  } else{
    df = data.frame(balance, covariates)
    balance_quantiles = quantile(balance, prob=quantile_plotted)
    balance_df = with(df, data.frame(balance = balance_quantiles))

    covariates_names = names(covariates)
    balance_df = cbind(balance_df, matrix(ncol=length(covariates_names), nrow=length(length(covariates_names))))
    for (key in 1:length(covariates_names)){
      if (class(covariates[, key]) == "factor"){
        balance_df[, key+1] = levels(covariates[, key])[1]
      } else{
        balance_df[, key+1]= mean(covariates[, key])
      }
    }
    names(balance_df)[-1] = covariates_names
  }

  if (model == "coxph") {
    result <- coxph(Surv_obj ~., data=df)

    fit <- survfit(result, newdata = balance_df, conf.int = 1-alpha)
    survival_plot = ggsurvplot(fit, data = balance_df, conf.int = T,
                               legend.labs=paste0('Balance=', round(balance_quantiles, digits=4), "(", quantile_plotted, ")"),
                               ggtheme = theme_minimal())
  } else if (model == "parametric"){
    if (is.na(dist)) {
      dist = "weibull"
    }
    result <- survreg(Surv_obj ~., dist=dist, data=df)

    pct <- 1:100/100

    df_for_plot <- data.frame()

    for (i in 1:length(quantile_plotted)){
      balance_quantile = data.frame(balance = balance_df[i,])
      names(balance_quantile) = names(balance_df)
      ptime_se <- predict(result, newdata=balance_quantile, type='quantile', p=pct, se=TRUE)
      #ptime_se <- ptime_se[which(ptime_se$fit < max(as.numeric(OS_Surv)))]
      ptime = t(ptime_se$fit)
      ptime_df = data.frame(ptime = ptime_se$fit,
                            prob = 1-pct,
                            variable = paste0("X", i))
      pse_df = data.frame(lb = ptime_se$fit - qnorm(1-alpha)*ptime_se$se.fit,
                          ub = ptime_se$fit + qnorm(1-alpha)*ptime_se$se.fit,
                          prob = 1-pct,
                          variable = paste0("X", i))
      df_merge = merge(ptime_df, pse_df, by = c("prob", "variable"))
      df_for_plot <- rbind(df_for_plot, df_merge)
    }

    df_for_plot <- df_for_plot[df_for_plot$ptime <= max(as.numeric(Surv_obj)) & df_for_plot$ptime >= 0, ]

    survival_plot = ggplot(df_for_plot, aes(x = ptime, y = prob)) +
      geom_line(aes(color = variable)) +
      xlab("Time") + ylab("Survival probability") +
      geom_ribbon(aes(xmin = lb, xmax = ub, fill = variable), alpha = 0.1) +
      scale_colour_discrete(name = "Strata", labels = paste0('Balance=', round(balance_quantiles, digits=4), "(", quantile_plotted, ")"))+
      guides(fill = "none") + theme_minimal() + theme(legend.position = "top")

  } else {
    stop("The only options of model specification are 'coxph' and 'parametric'.")
  }

  return (list(selection_path=mod, survival_model=result, balance_name=balance_name, balance=balance, survival_plot=survival_plot))

}

