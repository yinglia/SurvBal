#' STEP 0: pre_processing
#'
#' Process the given data by handling the inflated zeros, 
#' then computing the relative abundance and taking log transformation of the relative abundance
#'
#' @param Surv_obj an object of class \code{Surv} generated by
#' \code{\link[survival:Surv]{survival::Surv}}
#' @param data a \eqn{n \times p} matrix which is the raw taxon count table and needs to be processed, where rows are the samples, columns are the taxa
#' @param covariates a \eqn{n \times q} data frame containing important covariates for adjustment,
#' which could be a mixture of \eqn{q} continuous and discrete (pre-defined as factor) variables.
#' The default value is \code{NULL}
#' @param min_prevalence the minimum prevalence of taxa that could be considered in the selection procedure
#' @param mult_repl true or false, if the user wants to use Bayesian Multiplicative Replacement or not to handle inflated zeros, respectively
#'
#' @noRd

pre_processing <- function(Surv_obj, data, covariates, min_prevalence, mult_repl) {

  # remove rare taxa
  killbugs = which(apply(data>0, 2, mean) < min_prevalence)
  if (length(killbugs) > 0) data = data[, -killbugs]
  
  # perform MiRKAT association test
  
  # calculate relative abundance
  data_rel = t(apply(data, 1, function(z){ z/sum(z) }))
  
  # calculate distances
  D.jaccard = as.matrix(vegdist(as.matrix(data), method = 'jaccard', binary = T))
  D.bc = as.matrix(vegdist(as.matrix(data_rel), method = 'bray', binary = F))
  
  # convert distance to kernel matrices
  K.jaccard = MiRKAT::D2K(D.jaccard)
  K.bc = MiRKAT::D2K(D.bc)
  
  # testing using multiple kernels
  Ks = list(K.Jaccard = K.jaccard, 
            K.BC = K.bc)
  
  # whether using permutation 
  if (length(Surv_obj) < 100) {
    perm_status = TRUE
  } else {
    perm_status = FALSE
  }
  
  # a vector or matrix of numeric covariates
  if (!is.null(covariates)) {
    covariates_numeric = model.matrix(~ ., covariates)[, -1, drop = F]
  } else {
    covariates_numeric = NULL
  }
  
  mirkats_re <- MiRKATS(obstime = Surv_obj[, 'time'], 
                        delta = Surv_obj[, 'status'], 
                        X = covariates_numeric, Ks = Ks, 
                        perm = perm_status, omnibus = "permutation")

  # impute data by Bayesian Multiplicative Replacement or adding a constant then dividing sample library size
  if (mult_repl == TRUE){
    data_prepped = cmultRepl(data)
  } else{
    data = data + 0.5
    data_prepped = data / rowSums(data)
  }

  data_prepped = log(data_prepped) # take the log transformation

  return(list(global_test = mirkats_re$omnibus_p,
              data_prepped = data_prepped)) # return the result in the end

}
